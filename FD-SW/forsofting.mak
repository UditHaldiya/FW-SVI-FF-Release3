
export MN_CC:=Use MN settings
export BASE=$(CURDIR)/base
me:=$(PROJDIR)\$(lastword $(MAKEFILE_LIST))
include $(PROJDIR)/target/mak/makeconfig_common.mak
include $(PROJDIR)/base/mak/Makeenv.mak
include $(PROJDIR)/target/mak/std_settings.mak

#Add Softing flags
CFLAGS_PROJ += -Dexception_handler=default_exception_handler
ifneq ($(Hide),)
$(info CFLAGS_PROJ=$(CFLAGS_PROJ))
endif

ifeq ($(NOGEN),)
ifneq ($(filter REQIMPORT,$(MAKECMDGOALS)),)
FORCED_DEPENDENCY_LOCAL+=GenVFD
endif
endif

$(info MAKECMDGOALS=$(MAKECMDGOALS))
$(info *******************************)
$(info FORCED_DEPENDENCY_LOCAL=$(FORCED_DEPENDENCY_LOCAL))
$(info *******************************)

#Do not change unless you know what you are doing;
FFTokVer?=3.70
ifneq ($(FFTokVer),3.70)
export TokenizerDir:=..\FFTokenizer.3.82
export releasepath:=$(TokenizerDir)\DDL\RELEASE
Rev_Defs_H:=rev_defs.3.82.h
else
export TokenizerDir:=..\FFTokenizer
export releasepath:=$(TokenizerDir)\RELEASE
Rev_Defs_H:=rev_defs.3.70.h
endif
export TokenizerBin:=$(TokenizerDir)
export includepath:=$(TokenizerDir)\ddl

#Where Softing keeps their things
SOURCE_BINARY_DD:=$(releasepath)\$(manufacturer_ID)\$(DEVICE_TYPE)
TARGET_BINARY_DD:=$(PROJDIR)\target\appl\fbif\ddl\$(DEVICE_TYPE)
GW_DIR:=$(PROJDIR)\target\appl\fbif\script
export DDLDIR:=$(PROJDIR)\target/appl/fbif/ddl

#MN files of interest: they need versioning info
export DDLSRC:=$(DDLDIR)/svi_positioner.ddl
DDLINC:=$(DDLDIR)/svi_ids.h

.PHONY : GenVFD tok
#Refer to GenVFD_FF.pdf on the files generated by the tool. There are too many
#of them to list as separate targets

DDL_root := $(PROJDIR)\target\appl\fbif
GenVFD: tok
    cd $(DDL_root)\script && genVFD_FF.exe ../inc ../src ../ddl/$(DEVICE_TYPE)\$(DEVICE_REV)$(DD_REV).sy5 \
    $(MAIN_SCRIPT) -unpacked_structures
	echo Timestamp of GenVFD step %TIME% %DATE% >$@


# ----- experimental: Inserting Unimal scripts for single-entry code generation
nvport := $(PROJDIR)\inc_$(PROJ)\ff2nvram.inc $(PROJDIR)\inc_$(PROJ)\ff2nvram.h $(PROJDIR)\nvram\project_$(PROJ)\ff2nvram.c

iochannels_fb := ai mai ao di do
iochannels_gw := $(addsuffix fb.h,$(addprefix $(DDL_root)\script\channels_,$(iochannels_fb)))

iochannels:= $(iochannels_gw)
#iochannels:= $(iochannels_gw) $(DDL_root)\script\iochannels.h

uscripts_ptb := $(DDL_root)\script\ptb_custom.gw $(DDL_root)\ddl\svi_custom.h $(DDL_root)\ddl\svi_customvar.h $(DDL_root)\ddl\aggregwraps.h
uscripts:= $(uscripts_ptb) $(nvport) $(iochannels) $(DDL_root)\ddl\rb_customvar.h $(DDLDIR)\faultdef_ff.h

$(uscripts_ptb) : $(component_configuration)

$(DDL_root)\script\ptb_custom.gw : $(DDL_root)\script\gwout.u includes\gwgen.inc inc_$(PROJ)\ptb_custom.inc $(PROJDIR)\inc_$(PROJ)\gwtypes.inc
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O. -Soutfile="$@" $(DDL_root)\script\gwout.u

$(DDL_root)\ddl\aggregwraps.h : $(DDL_root)\script\aggregwraps.u inc_FFP\paramstubs.inc inc_$(PROJ)\ptb_custom.inc $(PROJDIR)\inc_$(PROJ)\gwtypes.inc
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O. -Soutfile="$@" $(DDL_root)\script\aggregwraps.u || pause

$(DDL_root)\ddl\svi_custom.h : $(DDL_root)\script\ddhout.u includes\ddhgen.inc inc_$(PROJ)\ptb_custom.inc $(PROJDIR)\inc_$(PROJ)\gwtypes.inc
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O. -Soutfile="$@" $(DDL_root)\script\ddhout.u

$(DDL_root)\ddl\svi_customvar.h : $(DDL_root)\script\ddvars.u includes\ddvargen.inc inc_$(PROJ)\ptb_custom.inc  $(PROJDIR)\inc_$(PROJ)\gwtypes.inc
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O. -Soutfile="$@" $(DDL_root)\script\ddvars.u

$(DDL_root)\ddl\rb_customvar.h : $(DDL_root)\script\rb_ddvars.u includes\ddvargen.inc inc_$(PROJ)\rb_custom.inc  $(PROJDIR)\inc_$(PROJ)\gwtypes.inc
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O. -Soutfile="$@" $(DDL_root)\script\rb_ddvars.u

$(nvport) : $(DDL_root)\script\lfout.u $(PROJDIR)\includes\lfgen.inc $(PROJDIR)\inc_$(PROJ)\ptb_custom.inc  $(PROJDIR)\inc_$(PROJ)\gwtypes.inc
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O. -Sidir=$(PROJDIR)\inc_$(PROJ) -Shdir=$(PROJDIR)\inc_$(PROJ) -Scdir=$(PROJDIR)\nvram\project_$(PROJ) -Sbname=ff2nvram $(DDL_root)\script\lfout.u

$(iochannels_gw) : $(DDL_root)\script\fbchannels.u $(PROJDIR)\inc_$(PROJ)\gwtypes.inc includes\iocgen.inc
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O$(DDL_root)\script $(DDL_root)\script\fbchannels.u

# Add fault bits generation for DD
SheetSelect_def=if ($$WS eq \"Faults\")
SheetSelect_txt=if ($$WS eq \"DD_Text\")

$(DDLDIR)\faultdef_ff.h : $(DDLDIR)\faultdef_ff.u $(DDLDIR)\faultdef_ff.inc
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O$(DDLDIR) $< >$@

$(DDLDIR)\faultdef_ff.inc : $(FAULTDEF)  $(LOCAL_CONF)
    $(MN_ECHO) "#MP; /* Automatically generated by ui/conf.mak from $< */" >$@
    $(MN_ECHO) "#MP ;The text below must be preceded by Expand faultdef_SetOption(e.g., faultdef_bitnums)" >>$@
    $(MN_ECHO) #MP StartFaultDef() >>$@
    $(MNTOOLS)/XLSperl.exe -nae "$(SheetSelect_def) {\
		if($$ROW.\"\" ne \"1\") {\
			if($$F[3] ne \"\" && $$F[3] ne \"Undefined\") {\
				print \"#MP FaultDef($$F[3], $$F[0])\n\";\
			};\
		};\
	}" $(FAULTDEF) >>$@
    $(MNTOOLS)/XLSperl.exe -nae "$(SheetSelect_txt) {\
		if($$ROW.\"\" ne \"1\") {\
			if($$F[0] ne \"\" && $$F[0] ne \"Undefined\") {\
				print \"#MP FaultDDTextDef($$F[0], #\@$$F[1]#)\n\";\
			};\
		};\
	}" $(FAULTDEF) >>$@
    $(MN_ECHO) #MP EndFaultDef() >>$@


doc := $(DDL_root)\script\paramdoc.html
pretok:=ffpretok.exe
#tok_exe:=ff_tok32.exe
#pretok:=ff5pretok.exe
tok_exe:=ff5_tok32.exe

FORCED_DEPENDENCY_LOCAL +=$(doc)
$(doc) : $(DDL_root)\script\htmldoc.u includes\htmltoc.inc includes\htmlbody.inc inc_FFP\ptb_custom.inc
	$(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) $< >$@

# ----- End experimental: Inserting Unimal scripts for single-entry code generation
define dd4_naked
	$(MAKE) -f $(PROJDIR)\ffo.mak pretok_exe=$(pretok) tok_exe=$(tok_exe) _tok \
	DDLSRC=$(DDLSRC) pretok=$(TARGET_BINARY_DD)\_tmptok-4 dst=$(TARGET_BINARY_DD) option="-DDD4 -4 -a" basename=$(SOURCE_BINARY_DD)/$(DEVICE_REV)$(DD_REV)
endef

define dd4
    $(MN_CP) $(TARGET_BINARY_DD)\symbols.txt $(SOURCE_BINARY_DD)\symbols.txt
    attrib -R $(SOURCE_BINARY_DD)\symbols.txt
    $(dd4_naked)
	sort $(SOURCE_BINARY_DD)\$(DEVICE_REV)$(DD_REV).sym > $(SOURCE_BINARY_DD)\$(DEVICE_REV)$(DD_REV).sym.ref
    $(igdiff)fc $(SOURCE_BINARY_DD)\$(DEVICE_REV)$(DD_REV).sym.ref $(TARGET_BINARY_DD)\$(DEVICE_REV)$(DD_REV).sym.ref
endef

define dd5_naked
	$(MAKE) -f $(PROJDIR)\ffo.mak _tok pretok_exe=$(pretok) tok_exe=$(tok_exe) DDLSRC=$(DDLSRC) pretok=$(TARGET_BINARY_DD)\_tmptok dst=$(TARGET_BINARY_DD) option=-a basename=$(SOURCE_BINARY_DD)/$(DEVICE_REV)$(DD_REV)
endef

define dd5
    $(MN_CP) $(TARGET_BINARY_DD)\symbols.txt $(SOURCE_BINARY_DD)\symbols.txt
    attrib -R $(SOURCE_BINARY_DD)\symbols.txt
    $(dd5_naked)
    sort $(SOURCE_BINARY_DD)\$(DEVICE_REV)$(DD_REV).sy5 > $(SOURCE_BINARY_DD)\$(DEVICE_REV)$(DD_REV).sy5.ref
    $(igdiff)fc $(SOURCE_BINARY_DD)\$(DEVICE_REV)$(DD_REV).sy5.ref $(TARGET_BINARY_DD)\$(DEVICE_REV)$(DD_REV).sy5.ref
endef

#------
define DD_clean
    -$(MN_RM) -f -r $(SOURCE_BINARY_DD)
    -cmd /E /C mkdir $(SOURCE_BINARY_DD)
endef

#These commands offer ultimate freedom but may require
#recompiling the firmware to match DD's .sym, .sy5, symbols.txt
define DD_devel
    @echo Making fresh DD, perhaps not backward compatible
    $(DD_clean)
	$(dd4_naked)
	$(dd5_naked)
endef

igdiff?= #Set to `-` on the command line to IGnore DIFFerences
#These commands fail on incompatible .sym, .sy5, symbols.txt
#but are compatible with existing firmware
#It is possible for this build to fail on adding a brand new DD item.
#In this case, you need to inspect the differences in .ref manually
#and if they are only in new additions, manually update the reference files
define DD_compat
    @echo Making backward compatible DD, must not require firmware rebuild
    $(DD_clean)
	$(dd4)
	$(dd5)
endef

ifeq (0,1)
define DD_test
    $(DD_clean)
    $(MAKE) -f $(PROJDIR)\ffo.mak  _tok pretok_exe=$(ffpretok) tok_exe=$(tok_exe) DDLSRC=$(DDLSRC) pretok=$(TARGET_BINARY_DD)\_tmptok-4 dst=$(TARGET_BINARY_DD) option="-DDD4 -4" basename=$(SOURCE_BINARY_DD)/$(DEVICE_REV)$(DD_REV)
    $(MAKE) -f $(PROJDIR)\ffo.mak _tok pretok_exe=$(ffpretok) tok_exe=$(tok_exe) DDLSRC=$(DDLSRC) pretok=$(TARGET_BINARY_DD)\_tmptok dst=$(TARGET_BINARY_DD) option= basename=$(SOURCE_BINARY_DD)/$(DEVICE_REV)$(DD_REV)
endef
endif

#We are doing new development for R3 but want to keep compatibity IF POSSIBLE with R2.1 and from build to build
DD_command = $(DD_compat)
#DD_command = $(DD_devel)

tok: $(DDLINC) $(GW_DIR)\ids.gw  $(uscripts)
    $(cmpcpy) $(includepath)\standard.sym $(releasepath)\standard.sym
	$(MN_CP) -f $(DDLDIR)\$(Rev_Defs_H) $(DDLDIR)\rev_defs.h
    $(DD_test)
    $(DD_command)
	echo Timestamp of tokenizer step %TIME% %DATE% >$@

$(DDLINC) : $(MAKEFILE_LIST)
    @echo MAKEFILE_LIST = $(MAKEFILE_LIST)
    echo MANUFACTURER      0x$(manufacturer_ID),>$@
    echo DEVICE_TYPE       0x$(DEVICE_TYPE),>>$@
    echo DEVICE_REVISION   $(DEVICE_REV),>>$@
    echo DD_REVISION       $(DD_REV)>>$@

Changeset:=$(if $(OFFver),$(OFFver),sandbox)

changeset.inc : $(MAKEFILE_LIST)
    @echo MAKEFILE_LIST = $(MAKEFILE_LIST)
    $(Hide)echo #MP Setstr Changeset="$(Changeset)" >$@

include ids.gwd

$(info ISUBDIR=$(ISUBDIR))

ids.gw ids.gwd: changeset.inc gw_rb_helper.u
	echo ISUBDIR=$(ISUBDIR)
    $(UNIMAL) -I. $(addprefix -I,$(ISUBDIR)) -O. -dids.wd_ gw_rb_helper.u
	@echo ids.gw : \>ids.tmp
	$(Hide)$(FIXDEP) ids.wd_>>ids.tmp
	del ids.gwd
	ren ids.tmp ids.gwd


$(GW_DIR)\ids.gw : ids.gw
    $(cmpcpy) $< $@


force1 : ;