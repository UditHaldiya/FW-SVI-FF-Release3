#MP If 0 ;Tombstone header
/*
Copyright 2004-2007 by Dresser, Inc., as an unpublished trade secret.  All rights reserved.
This document and all information herein are the property of Dresser, Inc.
It and its contents are  confidential and have been provided as a part of
a confidential relationship.  As such, no part of it may be made public,
decompiled, reverse engineered or copied and it is subject to return upon
demand.
*/
/**
    \file nvramtable.u
    \brief Generator of NVRAM layout table

    CPU: Any

    OWNER: AK

    \ingroup nvmem
*/
#MP Endif ;Tombstone header
#MP Setstr basename = uAutoLine
#MP Include "ustd.inc"

/**brief #MP GenEepShimGetSet is an intercept of Softing manipulation with their eep model
of NVMEM of function blocks.
It is responsible for reading/writing data in "eep blocks" replacements
but doesn't deal with NVMEM operations such as ram2nvramAtomic().
Actual write operations are performed or requested by a replacement of eep_put().
Likewise, CheckWord protection is off. The "get" function creates a valid
checksum at destination; that's all.
*/
#MP Macro GenEepShimGetSet ;[block-name, count]
EXTMEM ST_#mp%n#1##mp%n_t ST_#mp%n#1#[#mp%d#2#];
#MP Export (1) {uJoin, basename, ".h"}
#include <#mp%n#1#.h>
typedef struct ST_#mp%n#1#%n_t
{
#MP toupper({#1#})
    T_FBIF_#mp%stoupper#mp%n_STATIC data;
    u16 CheckWord;
} ST_#mp%n#1#%n_t;
EXTMEM extern ST_#mp%n#1##mp%n_t ST_#mp%n#1#[#mp%d#2#];
extern const ST_#mp%n#1##mp%n_t *eepshim_Get#mp%n#1##mp%nStaticData(u8_least index, ST_#mp%n#1##mp%n_t *dst);
#MP Export (1) {uJoin, basename, ".c"}
const ST_#mp%n#1##mp%n_t *eepshim_Get#mp%n#1##mp%nStaticData(u8_least index, ST_#mp%n#1##mp%n_t *dst)
{
    const ST_#mp%n#1##mp%n_t *ret;
    if(index >= NELEM(ST_#mp%n#1#))
    {
        ret = NULL;
    }
    else
    {
        ret = STRUCT_GET(&ST_#mp%n#1#[index], dst);
    }
    return ret;
}
#MP Export (1) {uJoin, basename, ".h"}

extern ErrorCode_t eepshim_Set#mp%n#1##mp%nStaticData(u8_least index, const ST_#mp%n#1##mp%n_t *src);
UNTYPEACCX(eepshim_Set#mp%n#1##mp%nStaticData, eepshim_Get#mp%n#1##mp%nStaticData);

#MP Export (1) {uJoin, basename, ".c"}
static const F_BLOCK * const #mp%n#1##mp%n_default_f_block[#mp%d#2#] =
{
#MP For ii=1, #2#
    [#mp%dii-1] = &#mp%n#1##mp%n_#mp%dii#mp%n_dft.blk_header,
#MP Endfor
};
ErrorCode_t eepshim_Set#mp%n#1##mp%nStaticData(u8_least index, const ST_#mp%n#1##mp%n_t *src)
{
    ErrorCode_t err;
    if(index >= NELEM(ST_#mp%n#1#))
    {
        err = ERR_INVALID_PARAMETER;
    }
    else
    {
        if(src == NULL)
        {
            /*Will be immediately overwritten so don't bother with content (yet)*/
                mn_memset(&ST_#mp%n#1#[index], EEP_INIT_VALUE, MN_OFFSETOF(ST_#mp%n#1##mp%n_t, CheckWord));
        }
        else
        {
            osif_disable_all_tasks();
                /* Copy verbatim*/ /*No data checks - left to app*/
                ST_#mp%n#1#[index] = *src;
                /* Override block data and Restore mutables in blk_data */
                #MP ;Find where the block defaults are
                #MP toupper({#1#})
                #MP Setstr block_id = "ID_" toupper "_1" ;Base id to which we add index
                const F_BLOCK *dft = #mp%n#1##mp%n_default_f_block[index];
                blk_data_Repair(&ST_#mp%n#1#[index].data.blk_data, &src->data.blk_data, dft);
                STRUCT_CLOSE(ST_#mp%n#1##mp%n_t, &ST_#mp%n#1#[index]);
            osif_enable_all_tasks();
        }
        err = ERR_OK;
    }
    return err;
}
#MP Endm
                #MP
#MP Export (0) {uJoin, basename, ".h"}
/*
Copyright 2017 by Dresser, Inc., as an unpublished trade secret.  All rights reserved.
This document and all information herein are the property of Dresser, Inc.
It and its contents are  confidential and have been provided as a part of
a confidential relationship.  As such, no part of it may be made public,
decompiled, reverse engineered or copied and it is subject to return upon
demand.
*/
/**
    \file #mp%sbasename.h
    \brief NVRAM shims for wrapping Softing eep block objects

    Do not edit this file manually; edit #mp%sbasename.u and/or its
    include files instead! Any edits will be overwritten!!!

    CPU: Any

    OWNER: #mp%sbasename.u

    \ingroup nvmem
*/
#ifndef #mp{%s toupper}_H_
#define #mp{%s toupper}_H_
                #MP
#MP ;Now, create the C file
#MP ;Export Push
#MP Export (0) {uJoin, basename, ".c"}
#MP ;print tombstone header for the generated .c file
/*
Copyright 2017 by Dresser, Inc., as an unpublished trade secret.  All rights reserved.
This document and all information herein are the property of Dresser, Inc.
It and its contents are  confidential and have been provided as a part of
a confidential relationship.  As such, no part of it may be made public,
decompiled, reverse engineered or copied and it is subject to return upon
demand.
*/
/**
    \file #mp%sbasename.c
    \brief Implementation of NVRAM shims for wrapping Softing eep block objects

    Do not edit this file manually; edit #mp%sbasename.u and/or its
    include files instead! Any edits will be overwritten!!!

    CPU: Any

    OWNER: #mp%sbasename.u

    \ingroup nvmem
*/

#include "mnwrap.h"
#include "nvram.h"
#include <eep_if.h>
#include <fdev_cfg.h>
#include <fbap.h>
#include <fbif.h>
#include <fbif_dcl.h>
#include <osif.h>
#include "nvmemids.h"
#include "eepshim.h"
#include "crc.h"
#include "asciicodes.h"

#MP GenEepShimGetSet(resb, 1)
#MP GenEepShimGetSet(ptb, 1)
#MP GenEepShimGetSet(aifb, 3)
#MP GenEepShimGetSet(aofb, 1)
#MP GenEepShimGetSet(difb, 2)
#MP GenEepShimGetSet(dofb, 2)
#MP GenEepShimGetSet(maifb, 1)
#MP GenEepShimGetSet(pidfb, 2)
#MP GenEepShimGetSet(isfb, 1)
#MP GenEepShimGetSet(osfb, 1)
#MP GenEepShimGetSet(csfb, 1)
#MP GenEepShimGetSet(arfb, 1)
/* This line marks the end of the source */
#MP     Export (1) {uJoin, basename, ".h"} ;switch the output
#endif
/* This line marks the end of the source */
#MP Save uJoin
#MP Setstr uJoin = "";
#MP Restore uJoin
