/*****************************************************************************
*                                                                            *
* PROJECT_NAME             Softing FF/PA FD 2.42                             *
*                                                                            *
* VERSION								                                     *
*											                                 *
*                                                                            *
* DATE                     29. Jan 2013		                                 *
*                                                                            *
*****************************************************************************/


/* ===========================================================================

FILE_NAME          ffbl_cs.c



FUNCTIONAL_MODULE_DESCRIPTION

=========================================================================== */
#include <keywords.h>
//ISSUE MODULE_ID
#define  MODULE_ID      (COMP_FFBL + MOD_FBLKIS)

INCLUDES

    /*@Dresser-Masoneilan project */
#include <string.h>

#include <base.h>
#include <osif.h>
#include <except.h>
    //#include "vfd.h"  - not used
#include <fbap.h>
#include <fbs_api.h>
#include <ffbl_int.h>
    //#include "ffbl_res.h" - not used
#include "fbif_fct.h"

#include "ffbl_cs.h"

    LOCAL_DEFINES

    LOCAL_TYPEDEFS

    FUNCTION_DECLARATIONS

    FUNCTION LOCAL VOID Check_config_CSFB (T_CSFB * p_csfb);
    FUNCTION LOCAL VOID Sort_inputs (T_IO_PAIR	inputs[], T_CSFB * p_csfb);
    FUNCTION LOCAL USIGN8 Calc_block_mode_CSFB (T_CSFB * p_csfb);
    FUNCTION LOCAL VOID Out_Limits_Handling
    (
    FLOAT_S *       par_out,
    USIGN8          actual_mode,
    FLOAT           hi_lim,
    FLOAT           lo_lim
    );

IMPORT_DATA

    EXPORT_DATA

    LOCAL_DATA


FUNCTION GLOBAL VOID Start_CSFB
    (
    T_FBIF_BLOCK_INSTANCE *    p_block_instance
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES
    T_CSFB *        p_csfb;
    T_CSFB_DATA *   p_csfb_data;

    FUNCTION_BODY

    if (p_block_instance->p_block_data == NULL)
    {
        p_block_instance->p_block_data = osif_malloc (sizeof(T_CSFB_DATA));
    }

    _ASSERT (p_block_instance->p_block_data != NULL);

    p_csfb      = p_block_instance->p_block_desc->p_block;
    p_csfb_data = p_block_instance->p_block_data;

    p_csfb_data->old_block_alarm_bits = 0;

    /* Disable update events ------------------------------------------------ */
    ffbl_disable_update_events (&p_csfb->update_evt);

    /* Store out param in the internal block-specific data structure -------- */
    p_csfb_data->out    = p_csfb->out;

    /* Set out status to BAD out-of-service --------------------------------- */
    p_csfb->out.status  = SQ_BAD|SUB_OUT_OF_SERVICE;

    /* Check function block configuration ----------------------------------- */
    Check_config_CSFB (p_csfb);

    return;
}

//lint -e818 Function prototype is auto generated by Softing's GenVFD tool
FUNCTION GLOBAL VOID Stop_CSFB
    (
    T_FBIF_BLOCK_INSTANCE *    p_block_instance
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES
    const T_FBIF_BLOCK_DESCR *  p_block_desc;
    T_CSFB *                    p_csfb;
    T_CSFB_DATA *               p_csfb_data;

    FUNCTION_BODY

    p_block_desc  = p_block_instance->p_block_desc;
    p_csfb        = p_block_desc->p_block;
    p_csfb_data   = p_block_instance->p_block_data;

    if (p_csfb->mode_blk.actual == MODE_OS)
    {
        return;
    }

    p_csfb->mode_blk.actual = MODE_OS;

    /* Set block error ------------------------------------------------------ */
    p_csfb->block_err |= BLK_ERR_OUT_OF_SERVICE;

    /* Store out param in the internal block-specific data structure -------- */
    p_csfb_data->out = p_csfb->out;

    /* Set status of output parameters -------------------------------------- */
    p_csfb->out.status = SQ_BAD|SUB_OUT_OF_SERVICE;
    p_csfb->bkcal_sel_1.status = SQ_BAD|SUB_OUT_OF_SERVICE;
    p_csfb->bkcal_sel_2.status = SQ_BAD|SUB_OUT_OF_SERVICE;
    p_csfb->bkcal_sel_3.status = SQ_BAD|SUB_OUT_OF_SERVICE;

    /* Disable update events ------------------------------------------------ */
    ffbl_disable_update_events (&p_csfb->update_evt);

    /* Update block alarm ----------------------------------------------- */
    ffbl_update_block_alarm
        (
        p_block_desc->block_id,p_block_desc->idx_blk_alm,
        BLK_ERR_OUT_OF_SERVICE,&p_csfb_data->old_block_alarm_bits
        );

    return;
}
//lint +e818



FUNCTION GLOBAL USIGN16 Read_handler_CSFB
    (
    T_FBIF_BLOCK_INSTANCE *     p_block_instance,
    T_FBIF_READ_DATA *          p_read
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES

    FUNCTION_BODY

    /* Check and/or update parameter to be read ----------------------------- */

    _UNREF_PARAM (p_block_instance);
    _UNREF_PARAM (p_read);

    return (E_OK);
}






FUNCTION GLOBAL USIGN16 Write_handler_CSFB
    (
    T_FBIF_BLOCK_INSTANCE *     p_block_instance,
    T_FBIF_WRITE_DATA *         p_write
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES
    const T_FBIF_BLOCK_DESCR *  p_block_desc;
    T_CSFB *                    p_csfb;
    T_CSFB_DATA *               p_csfb_data;
    USIGN8                      subindex;
    USIGN8 *                    source;
    USIGN16                     result;
    USIGN16                     unused_result;

    FUNCTION_BODY

    p_block_desc  = p_block_instance->p_block_desc;
    p_csfb_data   = p_block_instance->p_block_data;
    p_csfb        = p_block_desc->p_block;

    subindex      = p_write->subindex;
    source        = p_write->source;
    result        = E_OK;

    switch (p_write->rel_idx)
    {
    case CS_PAR_ALERT_KEY:
        {
            if (*source == 0)
            {
                result = E_FB_PARA_CHECK;
            }

            break;
        }

    case CS_PAR_MODE_BLK:
        {
            result = ffbl_check_mode (
                &p_csfb->mode_blk,
                subindex,
                source,
                MODE_IS_VALID
                );
            break;
        }

    case CS_PAR_GRANT_DENY:
        {
            ffbl_bas_write_grant_deny (subindex,source,&p_csfb->grant_deny);

            break;
        }

    case CS_PAR_STATUS_OPTS:
        {
            //if (MODE_NOT_OS(p_csfb->mode_blk.target))
            if (p_csfb->mode_blk.target != MODE_OS)
            {
                return (E_FB_WRONG_MODE);
            }

            //*((USIGN16 *)source) &= CS_STATUS_OPTS;  /* Delete all undefined bits */
            USIGN16 temp;
            mn_memcpy(&temp, source, sizeof(temp));
            temp &= CS_STATUS_OPTS; /* Delete all undefined bits */
            mn_memcpy(source, &temp, sizeof(temp));

            break;
        }

    case CS_PAR_SEL_TYPE:
        {
            // LINT correction -- binary neutral
            // if (MODE_LOWER_THAN_MAN(p_csfb->mode_blk.target))
            if ((p_csfb->mode_blk.target & (MODE_OS|MODE_MAN)) == 0u)
            {
                return (E_FB_WRONG_MODE);
            }

            if ((*source < CS_SEL_TYPE_HI)||(*source > CS_SEL_TYPE_MIDDLE))
            {
                return (E_FB_PARA_CHECK);
            }

            break;
        }

    case CS_PAR_UPDATE_EVT:
        {
            result = ffbl_check_unack_flag (&p_csfb->update_evt.unack, source, subindex);

            break;
        }

    case CS_PAR_BLOCK_ALM:
        {
            result = ffbl_check_unack_flag (&p_csfb->block_alm.unack, source, subindex);

            break;
        }

    case CS_PAR_OUT:
        {
            // LINT correction -- binary neutral
            // if (MODE_LOWER_THAN_MAN(p_csfb->mode_blk.target))
            if ((p_csfb->mode_blk.target & (MODE_OS|MODE_MAN)) == 0u)
            {
                return (E_FB_WRONG_MODE);
            }

            USIGN8 *  a_of_value;
            FLOAT     fvalue;

            if      (subindex == 0)
            {
                a_of_value = source + 1;
            }
            else if (subindex == 2)
            {
                a_of_value = source;
            }
            else /* (subindex == 1) */
            {
                return (E_FB_DATA_NO_WRITE);
            }

            memcpy (&fvalue, a_of_value, sizeof (fvalue));

            FLOAT_S temp;
            temp.value = fvalue;

            Out_Limits_Handling(&temp, p_csfb->mode_blk.actual, p_csfb->out_hi_lim, p_csfb->out_lo_lim);

            // This is a legitimate float equality comparison - to check if the value has been modified.
            // Comment for the LINT to ignore that particular issue.
            /*lint -save -e777 */
            if (temp.value != fvalue)
            {
                /* fvalue could have been modified by limits, copy it back to the telegram buffer */
                memcpy (a_of_value, &temp.value, sizeof (fvalue));
            }
            /*lint -restore */

            break;
        }

    case CS_PAR_OUT_HI_LIM:
    case CS_PAR_OUT_LO_LIM:
        {
            //check value is in range OUT_SCALE +/- 10%
            FLOAT temp = 0.0f;
            mn_memcpy(&temp, source, sizeof(temp));
            FLOAT deviation = (p_csfb->out_scale.eu_100 - p_csfb->out_scale.eu_0)/10;
            if ((temp > (p_csfb->out_scale.eu_100 + deviation)) || (temp < (p_csfb->out_scale.eu_0 - deviation)))
            {
                return (E_FB_PARA_CHECK);
            }

            //check HI is higher and LO is lower
            //allow HI equal to LO
            //check removed because of ITK test i3000_70
            //if (p_write->rel_idx == CS_PAR_OUT_HI_LIM)
            //{
            //    if (p_csfb->out_lo_lim > temp)
            //    {
            //        return (E_FB_PARA_CHECK);
            //    }
            //}
            //else
            //{
            //    if (p_csfb->out_hi_lim < temp)
            //    {
            //        return (E_FB_PARA_CHECK);
            //    }
            //}

            break;
        }

    case CS_PAR_OUT_SCALE:
        {
            if (p_csfb->mode_blk.target != MODE_OS)
            {
                return (E_FB_WRONG_MODE);
            }

            break;
        }
    default:
        {
            break;
        }
    }

    if (result == E_OK)
    {
        result = fbs_write_param (p_block_instance,p_write);
    }

    if (result == E_OK)
    {
        BOOL check_config = FALSE;

        switch (p_write->rel_idx)
        {
        case CS_PAR_MODE_BLK:
            {
                check_config = TRUE;

                T_FBS_WRITE_PARAM_LOCAL write_loc;

                write_loc.rel_idx = 0;

                if (p_csfb->mode_blk.target == MODE_OS)
                {
                    p_csfb->out.status = SQ_BAD|SUB_OUT_OF_SERVICE;

                    write_loc.rel_idx = CS_PAR_OUT;
                }
                else if (p_csfb->mode_blk.target == MODE_MAN)
                {
                    write_loc.rel_idx = CS_PAR_OUT;
                }
                else
                {
                    //no actions
                }

                if (write_loc.rel_idx != 0)
                {
                    /* Store out parameter in non-volatile RAM ---------------------- */
                    write_loc.subindex      = 0;
                    write_loc.length        = 5;
                    write_loc.source        = (USIGN8 *)&p_csfb->out;
                    write_loc.startup_sync  = FALSE;

                    unused_result = fbs_write_param_loc (p_block_instance,&write_loc);
                    UNUSED_OK(unused_result);
                }

                break;
            }

        case CS_PAR_OUT_HI_LIM:
        case CS_PAR_OUT_LO_LIM:
            {
                //handle the OUT value limits
                //mode is MAN or IMAN

                FLOAT_S temp;
                mn_memcpy(&temp, &p_csfb->out, sizeof(temp));

                Out_Limits_Handling(&temp, p_csfb->mode_blk.actual, p_csfb->out_hi_lim, p_csfb->out_lo_lim);

                //If OUT value is affected by limits then update OUT value and go to next CS_PAR_OUT case to store the new OUT value,
                //otherwise, break.
                if (temp.value > p_csfb->out.value)
                {
                    mn_memcpy(&p_csfb->out, &temp, sizeof(temp));
                }
                else
                {
                    if (temp.value < p_csfb->out.value)
                    {
                        mn_memcpy(&p_csfb->out, &temp, sizeof(temp));
                    }
                    else
                    {
                        break;
                    }
                }
                //If OUT value is affected by limits then update OUT value and go to next CS_PAR_OUT case to store the new OUT value,
                //otherwise, break.
            }

            // AP -- NOTE! Below for LINT!
            //lint -fallthrough

        case CS_PAR_OUT:
            {
                T_FBS_WRITE_PARAM_LOCAL write_loc;

                p_csfb->out.status = SQ_GOOD_NC;

                /* Store GOOD out status in non-volatile RAM ---------------------- */
                write_loc.rel_idx       = CS_PAR_OUT;
                write_loc.subindex      = 0;
                write_loc.length        = 5;
                write_loc.source        = (USIGN8 *)&p_csfb->out;
                write_loc.startup_sync  = FALSE;

                unused_result = fbs_write_param_loc (p_block_instance,&write_loc);
                UNUSED_OK(unused_result);

                /* Store out param in the internal block-specific data structure -- */
                p_csfb_data->out = p_csfb->out;

                /* Adapt out status in accordance to the actual mode -------------- */
                if (p_csfb->mode_blk.actual == MODE_OS)
                {
                    p_csfb->out.status = SQ_BAD|SUB_OUT_OF_SERVICE;
                }
                else
                {
                    p_csfb->out.status |= LIMIT_CONST;
                }

                break;
            }

        case CS_PAR_SEL_TYPE:
            {
                check_config = TRUE;
                break;
            }
        default:
            {
                check_config = TRUE;
                break;
            }
        }

        if (check_config == TRUE)
        {
            Check_config_CSFB (p_csfb);
        }
    }

    return (result);
}




FUNCTION GLOBAL USIGN16 Execute_CSFB
    (
    T_FBIF_BLOCK_INSTANCE *     p_block_instance
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    Return  next_fb_to_execute  next function block to be executed (used if
    'completion of block exec.' is set in CYCLE_SEL)

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES
    const T_FBIF_BLOCK_DESCR *    p_block_desc;
    T_CSFB *                      p_csfb;
    T_CSFB_DATA *                 p_csfb_data;
    USIGN8                        old_mode;
    USIGN8                        actual_mode;
    BOOL                          enable_update_evt;
    T_IO_PAIR                     inputs[3];
    FUNCTION_BODY

    //unusable initializations to suppress warnings
    inputs[0].p_sel = 0;
    inputs[0].p_bkcal_sel = 0;

    //local params initialization
    p_block_desc  = p_block_instance->p_block_desc;
    p_csfb        = p_block_desc->p_block;
    p_csfb_data   = p_block_instance->p_block_data;

    /* Update block mode -------------------------------------------------- */
    old_mode    = p_csfb->mode_blk.actual;
    Check_config_CSFB (p_csfb);
    actual_mode = Calc_block_mode_CSFB(p_csfb);

    if (actual_mode == MODE_OS)
    {
        if (old_mode != MODE_OS)
        {
            /* Mode OS is entered now ------------------------------------------- */
            Stop_CSFB (p_block_instance);
        }
        else
        {
            /* Update block alarm ----------------------------------------------- */
            ffbl_update_block_alarm
                (
                p_block_desc->block_id,p_block_desc->idx_blk_alm,
                BLK_ERR_OUT_OF_SERVICE,&p_csfb_data->old_block_alarm_bits
                );
        }
        //set the actual mode
        p_csfb->mode_blk.actual = actual_mode;
        return (p_csfb->blk_data.next_fb_to_execute);
    }

    //set the actual mode
    p_csfb->mode_blk.actual = actual_mode;

    if (old_mode == MODE_OS) /* Mode OS is left now ------------------------- */
    {
        /* Reset block error -------------------------------------------------- */
        p_csfb->block_err &= ~BLK_ERR_OUT_OF_SERVICE;
        enable_update_evt  = TRUE;
    }
    else
    {
        enable_update_evt = FALSE;
    }

    /* Mode is not OS -------------------------------------------- */

    /////////////////////////////////////////////////////////////////////////////
    /* Handle OUT parameter ---------------------------------------------------*/
    //OUT.Value Handling
    p_csfb->out.status = SQ_GOOD_CAS; //pre- set the out status
    if (actual_mode == MODE_AUTO)
    {
        if ((p_csfb->bkcal_in.status & LIMIT_MASK) == LIMIT_CONST)
        {
            //R11
            p_csfb->out.value = p_csfb->bkcal_in.value;
        }
        else
        {
            //R14 - Performs actual selection of inputs
            Sort_inputs(inputs, p_csfb);
            if (p_csfb->sel_type == CS_SEL_TYPE_HI)
            {
                p_csfb->out.value = inputs[2].p_sel->value;
                p_csfb->out.status = inputs[2].p_sel->status; //forward selected input status
            }
            else if (p_csfb->sel_type == CS_SEL_TYPE_MIDDLE)
            {
                p_csfb->out.value = inputs[1].p_sel->value;
                p_csfb->out.status = inputs[1].p_sel->status;
            }
            else //p_csfb->sel_type == CS_SEL_TYPE_LOW
            {
                p_csfb->out.value = inputs[0].p_sel->value;
                p_csfb->out.status = inputs[0].p_sel->status;
            }
        }
    }
    else
    {
        if (old_mode == MODE_OS) /* Mode OS is left now but not in AUTO --- */
        {
            /* Restore out parameter and clear OS flag ------------------------- */
            p_csfb->out.value = p_csfb_data->out.value;
        }
        else if (old_mode == MODE_AUTO)
        {
            //R20 - leave OUT.Value same as previous eval in AUTO mode
        }
        else //old_mode == MODE_IMAN
        {
            //Not Specified - But apply R20
        }

    }

    //OUT.Status Handling
    //p_csfb->out.status = SQ_GOOD_CAS;
    //out status is already set during input selection
    if (actual_mode == MODE_MAN)
    {
        //case when an input SEL_x is BAD and cause the MAN mode
        if ((p_csfb->mode_blk.target == MODE_AUTO) && ((p_csfb->status_opts & STATUS_OPT_IFS_IF_BAD_IN) == STATUS_OPT_IFS_IF_BAD_IN))
        {
            //R6
            p_csfb->out.status |= SUB_IFS;
        }
    }

    //OUT.Limits Handling
    Out_Limits_Handling(&p_csfb->out, actual_mode, p_csfb->out_hi_lim, p_csfb->out_lo_lim);

    /* END of Handle OUT parameter ---------------------------------------------------*/


    ////////////////////////////////////////////////////////////////////////////////////
    /* Handle BKCAL_SEL_n outputs ----------------------------------------------------*/

    if (((p_csfb->bkcal_in.status & (QUALITY_MASK | SUB_STATUS_MASK)) == (SQ_GOOD_CAS | SUB_NI)) //R7
        || ((p_csfb->bkcal_in.status & (QUALITY_MASK | SUB_STATUS_MASK)) == (SQ_GOOD_CAS | SUB_IR)) //R7
        || ((p_csfb->bkcal_in.status & (QUALITY_MASK | SUB_STATUS_MASK)) == (SQ_GOOD_CAS | SUB_LO)) //R7.1
        || ((p_csfb->bkcal_in.status & (QUALITY_MASK | SUB_STATUS_MASK)) == (SQ_GOOD_CAS | SUB_FSA)) //R7.1
        || ((p_csfb->bkcal_in.status & QUALITY_MASK) == SQ_BAD)) //Requirement by GE
    {
        //BKCAL_SEL_z are dependent from BKCAL_IN.Status
        p_csfb->bkcal_sel_1.status
            = p_csfb->bkcal_sel_2.status
            = p_csfb->bkcal_sel_3.status
            = p_csfb->bkcal_in.status;
        p_csfb->bkcal_sel_1.value
            = p_csfb->bkcal_sel_2.value
            = p_csfb->bkcal_sel_3.value
            = p_csfb->bkcal_in.value;
    }
    else //BKCAL_SEL_n are NOT dependent from BKCAL_IN.Status
    {
        //Value of each bkcal is same as out.
        p_csfb->bkcal_sel_1.value = p_csfb->bkcal_sel_2.value = p_csfb->bkcal_sel_3.value = p_csfb->out.value;

        //BKCAL_SEL_n Statuses + Limits
        if (actual_mode == MODE_AUTO)
        {
            if ((p_csfb->bkcal_in.status & LIMIT_MASK) == LIMIT_CONST)
            {
                p_csfb->bkcal_sel_1.status
                    = p_csfb->bkcal_sel_2.status
                    = p_csfb->bkcal_sel_3.status
                    = SQ_GOOD_CAS | SUB_NS | LIMIT_CONST;
            }
            else
            {
                //Selection has been applied - uses sorted 'input-output' pairs during OUT.Value selection
                if (p_csfb->sel_type == CS_SEL_TYPE_HI)
                {
                    inputs[0].p_bkcal_sel->status = SQ_GOOD_CAS | SUB_NS | LIMIT_LOW;
                    inputs[1].p_bkcal_sel->status = SQ_GOOD_CAS | SUB_NS | LIMIT_LOW;
                    inputs[2].p_bkcal_sel->status = SQ_GOOD_CAS | (p_csfb->bkcal_in.status & SUB_STATUS_MASK); //R8
                }
                else if (p_csfb->sel_type == CS_SEL_TYPE_MIDDLE)
                {
                    inputs[0].p_bkcal_sel->status = SQ_GOOD_CAS | SUB_NS | LIMIT_LOW;
                    inputs[1].p_bkcal_sel->status = SQ_GOOD_CAS | (p_csfb->bkcal_in.status & SUB_STATUS_MASK); //R8
                    inputs[2].p_bkcal_sel->status = SQ_GOOD_CAS | SUB_NS | LIMIT_HIGH;
                }
                else //p_csfb->sel_type == CS_SEL_TYPE_LOW
                {
                    inputs[0].p_bkcal_sel->status = SQ_GOOD_CAS | (p_csfb->bkcal_in.status & SUB_STATUS_MASK); //R8
                    inputs[1].p_bkcal_sel->status = SQ_GOOD_CAS | SUB_NS | LIMIT_HIGH;
                    inputs[2].p_bkcal_sel->status = SQ_GOOD_CAS | SUB_NS | LIMIT_HIGH;
                }

                //if OUT value is limited its limit should be outputed
                if ((p_csfb->out.status & LIMIT_MASK) != NO_LIMIT)
                {
                    //clear limits
                    p_csfb->bkcal_sel_1.status &= ~LIMIT_MASK;
                    p_csfb->bkcal_sel_2.status &= ~LIMIT_MASK;
                    p_csfb->bkcal_sel_3.status &= ~LIMIT_MASK;

                    //set limits same as OUT.Limits
                    p_csfb->bkcal_sel_1.status |= p_csfb->out.status & LIMIT_MASK;
                    p_csfb->bkcal_sel_2.status |= p_csfb->out.status & LIMIT_MASK;
                    p_csfb->bkcal_sel_3.status |= p_csfb->out.status & LIMIT_MASK;
                }
            }
        }
        else //acutal_mode == (MODE_MAN or MODE_IMAN)
        {
            p_csfb->bkcal_sel_1.status
                = p_csfb->bkcal_sel_2.status
                = p_csfb->bkcal_sel_3.status
                = SQ_GOOD_CAS | SUB_NI | LIMIT_CONST;
        }
    }


    /* Update block alarm --------------------------------------------------- */

    ffbl_update_block_alarm
        (
        p_block_desc->block_id,p_block_desc->idx_blk_alm,
        p_csfb->block_err,&p_csfb_data->old_block_alarm_bits
        );

    if (enable_update_evt == TRUE)
    {
        ffbl_enable_update_events
            (
            p_block_desc->block_id,
            p_block_desc->idx_upd_evt,
            &p_csfb->update_evt,
            p_csfb->st_rev
            );
    }

    return(p_csfb->blk_data.next_fb_to_execute);
}






FUNCTION GLOBAL VOID Background_CSFB
    (
    T_FBIF_BLOCK_INSTANCE *    p_block_instance
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION:

    PARAMETERS:
    p_block_instance

    RETURN_VALUES:
    none
    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES

    FUNCTION_BODY

    _UNREF_PARAM (p_block_instance);

    return;
}





FUNCTION LOCAL VOID Check_config_CSFB
    (
    T_CSFB *   p_csfb
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES
    USIGN32   block_err_desc;

    FUNCTION_BODY

    block_err_desc = BLK_ERR_NO_ERROR;

    if (p_csfb->blk_data.period_of_execution == 0)
    {
        block_err_desc |= BLK_ERR_CS_EXE_TIME;
    }

    if (p_csfb->sel_type == CS_SEL_TYPE_UNINITIALIZED)
    {
        block_err_desc |= BLK_ERR_CS_SELECT_TYPE_UNINIT;
    }

    //check limits - allow HI and LO to be equal for ITK tests
    if (p_csfb->out_hi_lim < p_csfb->out_lo_lim)
    {
        block_err_desc |= (BLK_ERR_CS_HI_LIM_RANGE | BLK_ERR_CS_LO_LIM_RANGE);
    }
    //check HI LIMIT range
    FLOAT deviation = (p_csfb->out_scale.eu_100 - p_csfb->out_scale.eu_0)/10;
    if ((p_csfb->out_hi_lim > (p_csfb->out_scale.eu_100 + deviation)) || (p_csfb->out_hi_lim < (p_csfb->out_scale.eu_0 - deviation)))
    {
        block_err_desc |= BLK_ERR_CS_HI_LIM_RANGE;
    }

    //check LO LIMIT range
    if ((p_csfb->out_lo_lim > (p_csfb->out_scale.eu_100 + deviation)) || (p_csfb->out_lo_lim < (p_csfb->out_scale.eu_0 - deviation)))
    {
        block_err_desc |= BLK_ERR_CS_LO_LIM_RANGE;
    }

    if (block_err_desc == BLK_ERR_NO_ERROR)
    {
        p_csfb->block_err &= ~BLK_ERR_BLOCK_CONFIG_ERR;
    }
    else
    {
        p_csfb->block_err |= BLK_ERR_BLOCK_CONFIG_ERR;
    }

    p_csfb->block_err_desc_1 = block_err_desc;

    return;
}


FUNCTION LOCAL USIGN8 Calc_block_mode_CSFB
    (
    T_CSFB *         p_csfb
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES
    USIGN8	actual_mode;
    FUNCTION_BODY

    //apply standart mode calc
    actual_mode = ffbl_bas_calc_block_mode (&p_csfb->mode_blk, p_csfb->block_err);

    //apply CS block specific mode calc
    if (actual_mode == MODE_AUTO)
    {
        //check the input states:
        //if any input is 'Bad' actual mode goes to MAN
        if (((p_csfb->sel_1.status & QUALITY_MASK) == SQ_BAD)
            || ((p_csfb->sel_2.status & QUALITY_MASK) == SQ_BAD)
            || ((p_csfb->sel_3.status & QUALITY_MASK) == SQ_BAD))
        {
            actual_mode = MODE_MAN;
        }
        //if BKCAL_IN is BAD goes to IMAN
        else if ((p_csfb->bkcal_in.status & QUALITY_MASK) == SQ_BAD)
        {
            actual_mode = MODE_IMAN;
        }
        //if an input is 'Uncertain' it is treated as BAD unless STATUS_OPTS 'Use Uncertain as Good' is set.
        else if (((p_csfb->sel_1.status & QUALITY_MASK) == SQ_UNCERTAIN)
            || ((p_csfb->sel_2.status & QUALITY_MASK) == SQ_UNCERTAIN)
            || ((p_csfb->sel_3.status & QUALITY_MASK) == SQ_UNCERTAIN))
        {
            if ((p_csfb->status_opts & STATUS_OPT_USE_UNCERT_AS_GOOD) == STATUS_OPT_USE_UNCERT_AS_GOOD)
            {
                actual_mode = MODE_AUTO;
            }
            else
            {
                actual_mode = MODE_MAN;
            }
        }
        //if it is OK to go in AUTO, but current mode is OS then go through IMAN first for next cycle
        else if (p_csfb->mode_blk.actual == MODE_OS)
        {
            actual_mode = MODE_IMAN;
        }
        else
        {
            //mode stays auto
        }
    }
    //if it is OK to go in AUTO, go through IMAN first instead MAN as 'ffbl_bas_calc_block_mode' wants
    else if ((actual_mode == MODE_MAN) && (p_csfb->mode_blk.target == MODE_AUTO))
    {
        actual_mode = MODE_IMAN;
    }
    else
    {
        //mode stays auto
    }
    return actual_mode;
}

FUNCTION LOCAL VOID Out_Limits_Handling
    (
    FLOAT_S *       par_out,
    USIGN8          actual_mode,
    FLOAT           hi_lim,
    FLOAT           lo_lim
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES
    FUNCTION_BODY

    //clear limits - for all modes
    par_out->status &= ~LIMIT_MASK;
    if (actual_mode != MODE_OS)
    {
        //for modes AUTO/IMAN/MAN
        if (par_out->value <= lo_lim)
        {
            par_out->value = lo_lim;
            par_out->status |= LIMIT_LOW;
        }

        if (par_out->value >= hi_lim)
        {
            par_out->value = hi_lim;
            par_out->status |= LIMIT_HIGH;
        }

        if ((actual_mode == MODE_MAN) || (actual_mode == MODE_IMAN))
        {
            par_out->status |= LIMIT_CONST;
        }
    }
}

FUNCTION LOCAL VOID Sort_inputs
    (
    OUT T_IO_PAIR	inputs[3],
    T_CSFB *      p_csfb
    )

    /*----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    ----------------------------------------------------------------------------*/
{
    LOCAL_VARIABLES
    T_IO_PAIR temp;
    FUNCTION_BODY

    inputs[0].p_sel = &p_csfb->sel_1;
    inputs[0].p_bkcal_sel = &p_csfb->bkcal_sel_1;
    inputs[1].p_sel = &p_csfb->sel_2;
    inputs[1].p_bkcal_sel = &p_csfb->bkcal_sel_2;
    inputs[2].p_sel = &p_csfb->sel_3;
    inputs[2].p_bkcal_sel = &p_csfb->bkcal_sel_3;


    if (inputs[0].p_sel->value > inputs[1].p_sel->value)
    {
        if (inputs[0].p_sel->value > inputs[2].p_sel->value)
        {
            //swap 0 with 2
            temp = inputs[0];
            inputs[0] = inputs[2];
            inputs[2] = temp;
        }
        else
        {
            //swap 0 with 1
            temp = inputs[0];
            inputs[0] = inputs[1];
            inputs[1] = temp;
        }
    }
    else if (inputs[1].p_sel->value > inputs[2].p_sel->value)
    {
        //swap 1 with 2
        temp = inputs[1];
        inputs[1] = inputs[2];
        inputs[2] = temp;
    }
    else
    {
        //array is ordered - no actions needed
        return;
    }

    if (inputs[0].p_sel->value > inputs[1].p_sel->value)
    {
        //swap 0 with 1
        temp = inputs[0];
        inputs[0] = inputs[1];
        inputs[1] = temp;
    }

}
